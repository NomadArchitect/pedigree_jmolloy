####################################
# SCons build system for Pedigree
## Tyler Kennedy (AKA Linuxhq AKA TkTech)
####################################

import os
import shutil
import tempfile
Import(['env'])

tmp = env.Clone()

# Build directories
builddir = "#" + env["PEDIGREE_BUILD_BASE"]
kerneldir = "#" + env["PEDIGREE_BUILD_KERNEL"]
moduledir = "#" + env["PEDIGREE_BUILD_MODULES"]
subsysdir = "#" + env["PEDIGREE_BUILD_SUBSYS"]

# Change to then name of this module
posix_objname = subsysdir + '/posix.o'
glue_objname = 'pedigree-glue.o'
crt0_objname = kerneldir + '/crt0.o'
libpthread_objname = builddir + '/libpthread.a'
crti_objname = kerneldir + '/crti.o'
crtn_objname = kerneldir + '/crtn.o'

env.Alias("crt", [crt0_objname, crti_objname, crtn_objname])
env.Alias("subsys", posix_objname)
env.Alias("subsys", glue_objname)
env.Alias("pthreads", libpthread_objname)

# To include a new subdirectory just add to the list.
subdirs = [
    
]

# To include new files just add to the list, or Glob("*.cpp")
posix_files = [
    Glob("*.cc")
]

glue_files = [
    'glue.c',
    'glue-sysconf.c',
    'glue-fseek.c'
]

crt0_files = ['crt0.c']

suffix = '-noarch'
if env['ARCH_TARGET'] == 'X86':
    suffix = '-i686'
elif env['ARCH_TARGET'] == 'X64':
    suffix = '-amd64'
if env['ARCH_TARGET'] == 'PPC':
    suffix = '-ppc'

posix_files += ["sigret" + suffix + ".s"]

pthread_files = ['glue-pthread.c']

# CRTI/CRTN
crti_files = ["crti" + suffix + ".s"]
crtn_files = ["crtn" + suffix + ".s"]

# To include a new directory for includes, just add it to the list
include = [
    './include',
    '#/src/system/include',
    '#/src/modules/system',
    '.'
]

# To add a library add to the list below
libraries = [
    'gcc'
]

# To add a library path add to the list below
libpaths = [
    env['LIBGCC']
]

####################################
SConscript([os.path.join(i, 'SConscript') for i in subdirs],exports = ['tmp'])
tmp['CPPPATH'] = [i for i in include]
tmp['LIBS'] = [i for i in libraries]
tmp['LIBPATH'] = [i for i in libpaths]
#^-- Stupid way of doing it but I plan on adding processing.

tmp.objects = [tmp.Object(i) for i in posix_files]
if not len(posix_files) == 0:
    build = tmp.Program(posix_objname,tmp.objects,LINKFLAGS='-nostdlib -r -T $LSCRIPT',LSCRIPT=File("#src/modules/link.ld"))

# TODO: need to set -fPIC for x86, but that means we can't use %ebx for syscalls, which causes an error.
glueFlags = ""
if env['ARCH_TARGET'] == 'X64':
    glueFlags = "-mcmodel=small -fPIC " + glueFlags
    
tmp_glue = tmp.Clone()

tmp_glue.objects = [tmp.Object(i) for i in glue_files]
if not len(glue_files) == 0:
    build = tmp_glue.Program(glue_objname,tmp_glue.objects,LINKFLAGS='-nostdlib -r ' + glueFlags)

tmp_crt0 = tmp.Clone()

# No libraries needed for CRT0
tmp_crt0['LIBS'] = ''
tmp_crt0.objects = [tmp.Object(i) for i in crt0_files]
if not len(crt0_files) == 0:
    build = tmp_crt0.Program(crt0_objname,tmp_crt0.objects,LINKFLAGS='-nostdlib -r')
    
# CRTI
tmp_crti = tmp.Clone()
tmp_crti.objects = [tmp.Object(i) for i in crti_files]
if not len(crti_files) == 0:
    build = tmp_crti.Program(crti_objname,tmp_crti.objects,LINKFLAGS='-nostdlib -r')

# CRTN
tmp_crtn = tmp.Clone()
tmp_crtn.objects = [tmp.Object(i) for i in crtn_files]
if not len(crtn_files) == 0:
    build = tmp_crtn.Program(crtn_objname,tmp_crtn.objects,LINKFLAGS='-nostdlib -r')

# libpthread
tmp_pthread = tmp.Clone()
tmp_pthread.objects = [tmp.Object(i) for i in pthread_files]
if not len(crtn_files) == 0:
    build = tmp_pthread.Library(libpthread_objname, tmp_pthread.objects)

# Build libc/libm

if env['ARCH_TARGET'] == 'X86':
    libc_arch = 'i686'
elif env['ARCH_TARGET'] == 'X64':
    libc_arch = 'amd64'
elif env['ARCH_TARGET'] == 'PPC':
    driver_arch = 'ppc'

base = tmp.Dir("#")
baseLibc = tmp.File("#src/subsys/posix/newlib-" + libc_arch + "-libc.a")
baseLibm = tmp.File("#src/subsys/posix/newlib-" + libc_arch + "-libm.a")
baseInclude = tmp.Dir("#src/subsys/posix/include")

buildDir = tmp.Dir(builddir)
buildLibc = tmp.File(builddir + '/libc.so')
buildLibm = tmp.File(builddir + '/libm.so')
buildLibcA = tmp.File(builddir + '/libc.a')
buildLibmA = tmp.File(builddir + '/libm.a')
buildInclude = tmp.Dir(builddir + '/include-posix')

env.Alias("libs", [buildLibc, buildLibm])
env.Alias("crt0", "crt")

# TODO: Put into a script, clean up. This is kind of horrible.

def doLibm(target, source, env):
    builddir = '#' + env['BUILDDIR']
    
    buildDir = tmp.Dir(builddir)
    buildLibc = tmp.File(builddir + '/libc.so')
    buildLibm = tmp.File(builddir + '/libm.so')
    buildLibcA = tmp.File(builddir + '/libc.a')
    buildLibmA = tmp.File(builddir + '/libm.a')
    
    print "Building libm..."

    tmpdir = tempfile.mkdtemp()

    olddir = os.getcwd()
    os.chdir(tmpdir)
    shutil.copy(baseLibm.abspath, tmpdir + "/libm.a")

    os.system(env['AR'] + " x libm.a")
    os.system(env['CC_NOCACHE'] + " -nostdlib -shared -Wl,-shared -Wl,-soname,libm.so -L" + env['LIBGCC'] + " -o " + buildLibm.abspath + " *.o -lgcc")
    os.system(env['AR'] + " cru " + buildLibmA.abspath + " *.o")

    for i in os.listdir("."):
        os.remove(i)

    os.chdir(olddir)
    os.rmdir(tmpdir)
    
    print "libm built!"

#    builddir, inputLibcA, glue_name
    
env.Command([buildLibc], ["subsys", glue_objname], "@python " + base.abspath + "/scripts/buildLibc.py " + buildDir.abspath + " " + buildLibcA.abspath + " " + glue_objname + " " + env["AR"] + " " + env["CC_NOCACHE"] + " " + env["LIBGCC"])
env.Command([buildLibm], ["subsys"], "@python " + base.abspath + "/scripts/buildLibm.py " + buildDir.abspath + " " + buildLibmA.abspath + " " + env["AR"] + " " + env["CC_NOCACHE"] + " " + env["LIBGCC"])

# env.Command([buildLibc, buildLibm], "subsys", '@echo Building libc/libm... && perl ' + base.abspath + '/scripts/posixBlendLibc.pl ' + baseLibc.abspath + ' ' + baseLibm.abspath + ' ' + buildDir.abspath + '/src/subsys/posix/pedigree-glue.o ' + baseInclude.abspath + ' ' + tmp['CC'] + ' ' + tmp['AR'] + ' ' + buildDir.abspath + ' ' + tmp['LIBGCC'])
